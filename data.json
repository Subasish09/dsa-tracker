{
  "logs": [
    {
      "title": "You are given a sorted array of integers numbers and an integer target.  Find two distinct elements in the array such that their sum equals target.  Return the indices (1-based) of these two elements.",
      "logic": "# Two Pointers – Problem 2 (Pair Sum with Indices)\n\n## Problem Statement\n\nYou are given a **sorted array of integers** `numbers` and an integer `target`.\n\nFind **two distinct elements** in the array such that their sum equals `target`.\n\nReturn the **indices (1-based)** of these two elements.\n\n### Constraints\n- The array is sorted in **non-decreasing order**\n- Exactly **one valid solution exists**\n- You may not use the same element twice\n- You must use **constant extra space**\n\n---\n\n## Example\n\nInput:\n \nnumbers = [2, 3, 3, 4, 6]\ntarget = 6\n\nOutput:\n[2, 3]\n\nExplanation:\\\nnumbers[2] + numbers[3] = 3 + 3 = 6\n\n\n---\n\n## Pattern Recognition\n\nClues in the problem:\n- Sorted array\n- Pair sum\n- Exactly one solution\n\n➡️ **Two Pointers**\n\nDuplicates do **not** change the algorithm.\n\n---\n\n## Core Idea\n\nBecause the array is sorted:\n- The left pointer starts from the smallest element\n- The right pointer starts from the largest element\n\nBy adjusting the pointers intelligently, we can find the pair in **O(n)** time.\n\n---\n\n## Pointer Initialization\n\n- `left = 0`\n- `right = n - 1`\n\n---\n\n## Pointer Movement Rules\n\nLet:\\\nsum = numbers[left] + numbers[right]\n\n\n### Case 1: `sum == target`\n- Pair found\n- Return indices: `[left + 1, right + 1]`\n\n### Case 2: ```sum < target```\n- Sum is too small\n- Move `left` pointer to the right (`left++`)\n\n### Case 3: `sum > target`\n- Sum is too large\n- Move `right` pointer to the left (`right--`)\n\n---\n\n## Loop Condition\n\nwhile (left < right)\n\nWhy:\n- Prevents using the same element twice\n- Ensures valid pair selection\n\n---\n\n## Dry Run Example\n\nInput:\\\nnumbers = [1, 1, 2, 3, 4, 4, 9]\ntarget = 8\n\nSteps:\\\nL=1, R=9 → sum=10 → move R\\\nL=1, R=4 → sum=5 → move L\\\nL=1, R=4 → sum=5 → move L\\\nL=2, R=4 → sum=6 → move L\\\nL=3, R=4 → sum=7 → move L\\\nL=4, R=4 → sum=8 → FOUND\n\nFinal Indices (1-based):\n[5, 6]\n\n\n---\n\n## Time and Space Complexity\n\n- Time Complexity: `O(n)`\n- Space Complexity: `O(1)`\n\n---\n\n## Common Mistakes to Avoid\n\n- Allowing `left == right`\n- Returning values instead of indices\n- Using hash maps unnecessarily\n- Forgetting 1-based indexing\n\n---\n\n## Interview One-Line Explanation\n\n> Since the array is sorted, I use two pointers from both ends.\n> I move the left pointer if the sum is too small and the right pointer if the sum is too large.\n> When the sum equals the target, I return the 1-based indices.\n\n---\n\n## Pattern Recognition Trigger\n\nIf a problem mentions:\n- Sorted array\n- Two numbers\n- Target sum\n\nThink immediately:\n**Two Pointers**\n",
      "code": "/*\nYou are given a sorted array of integers numbers and an integer target.\n\nFind two distinct elements in the array such that their sum equals target.\n\nReturn the indices (1-based) of these two elements.\n\nConstraints\nThe array is sorted in non-decreasing order\nExactly one valid solution exists\nYou may not use the same element twice\nYou must use constant extra space\n*/\n\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> twoSum(vector<int>& numbers, int target) {\n    int l = 0, r = numbers.size() - 1;\n\n    while (l < r) {\n        int sum = numbers[l] + numbers[r];\n\n        if (sum > target) {\n            r--;\n        } else if (sum < target) {\n            l++;\n        } else {\n            // return 1-based indices\n            return {l + 1, r + 1};\n        }\n    }\n\n    return {};\n}\n\n\nint main() {\n    vector<int> v = {1, 1, 2, 3, 4, 4, 9};\n    int target = 15;\n    vector<int> res = twoSum(v, target);\n    \n    if (res.size() == 0) {\n        cout << \"not found\" << endl;\n    } else {\n        cout << \"Two Sum: \" << res[0] << \", \" << res[1] << endl;\n    }\n\n    return 0;\n}\n",
      "difficulty": "Easy",
      "topic": "Array - Two Pointer",
      "date": "20/01/2026",
      "id": 1768876505216
    },
    {
      "title": "Given a sorted array of integers and a target value, determine if there exist two numbers whose sum equals the target",
      "logic": "# Two Pointers Technique (Pattern Notes)\n\n## When to Use Two Pointers\n\nUse **Two Pointers** when you see:\n- Sorted array or sorted string\n- Problems asking for a pair / triplet\n- Conditions like sum, difference, comparison\n- Need to optimize from O(n²) to O(n)\n\n---\n\n## Canonical Problem Type\n\n> Given a sorted array, determine if there exist two elements whose sum equals a target.\n\n---\n\n## Core Idea\n\nBecause the array is **sorted**:\n- Left side has the smallest values\n- Right side has the largest values\n\nUsing two pointers allows us to adjust the sum intelligently instead of checking all pairs.\n\n---\n\n## Pointer Initialization\n\n- `left` starts at index `0`\n- `right` starts at index `n - 1`\n\n---\n\n## Pointer Movement Rules (Key Logic)\n\nLet: current_sum = nums[left] + nums[right]\n\n\n### If `current_sum == target`\n- Pair found\n- Return `true`\n\n### If `current_sum < target`\n- Sum is too small\n- Move `left` pointer to the right (`left++`)\n- Reason: increase the sum\n\n### If `current_sum > target`\n- Sum is too large\n- Move `right` pointer to the left (`right--`)\n- Reason: decrease the sum\n\n---\n\n## Loop Condition\n\nwhile (left < right)\n\n\nReason:\n- A number cannot pair with itself\n- All valid pairs are checked before pointers cross\n\n---\n\n## Dry Run Example\n\nArray: `[1, 2, 4, 6, 9]`\n\nTarget: 8\n\nSteps: \\\nL=1, R=9 → sum=10 → move R \\\nL=1, R=6 → sum=7 → move L \\\nL=2, R=6 → sum=8 → found \n\n\n---\n\n## Time & Space Complexity\n\n- Time Complexity: `O(n)`\n- Space Complexity: `O(1)`\n\n---\n\n## Common Mistakes to Avoid\n\n- Using nested loops\n- Ignoring the sorted property\n- Moving both pointers at the same time\n- Using extra data structures unnecessarily\n\n---\n\n## Interview One-Line Explanation\n\n> Since the array is sorted, I use two pointers from both ends.\n> If the sum is smaller than the target, I move the left pointer.\n> If it is larger, I move the right pointer.\n\n---\n\n## Pattern Recognition Trigger\n\nIf a problem mentions:\n- Sorted array\n- Pair of elements\n- Sum or comparison\n\nThink immediately:\n**Two Pointers**\n",
      "code": "/*\nGiven a sorted array of integers and a target value, determine if there exist two numbers\nwhose sum equals the target\n*/\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool hasPairWithSum(vector<int>& nums, int target) {\n    int l = 0, r = nums.size() - 1;\n\n    while (l < r) {\n        int sum = nums[l] + nums[r];\n\n        if (sum < target) {\n            l++;\n        } else if (sum > target) {\n            r--;\n        } else {\n            return true;\n        }\n    }\n    return false;\n}\n\n\nint main() {\n    vector<int> v = {2, 3, 5, 8, 11};\n    int target = 16;\n\n    bool present = hasPairWithSum(v, target);\n\n    cout << \"The target is \" << present << endl;\n\n    return 0;\n}\n",
      "difficulty": "Easy",
      "topic": "Array - Two Pointer",
      "date": "19/01/2026",
      "id": 1768830769172
    }
  ],
  "history": [
    "19/01/2026",
    "20/01/2026"
  ]
}