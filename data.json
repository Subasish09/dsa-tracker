{
  "logs": [
    {
      "title": "Given a string s, find the length of the longest substring without repeating characters.",
      "logic": "# Two Pointers – Problem 5 (Longest Substring Without Repeating Characters)\n\n## Problem Statement\n\nGiven a string `s`, find the length of the **longest substring** without repeating characters.\n\nA substring is a **contiguous** sequence of characters.\n\n---\n\n## Examples\n\nInput: \\\ns = \"abcabcbb\"\n\nOutput: 3\n\nExplanation:\\\n\"abc\" is the longest substring without repeating characters\n\n---\n\nInput:\\\ns = \"bbbbb\"\n\nOutput: 1\n\n---\n\nInput:\\\ns = \"pwwkew\"\n\nOutput: 3\n\nExplanation:\\\n\"wke\" is the longest substring without repeating characters\n\n---\n\n## Pattern Recognition\n\nClues in the problem:\n- Substring (contiguous)\n- Need maximum length\n- Repeating characters\n- Sliding window behavior\n\n➡️ **Two Pointers + Sliding Window**\n\nThis is NOT simple two pointers from ends.\n\n---\n\n## Core Idea (VERY IMPORTANT)\n\nMaintain a **window [left, right]** such that:\n- All characters inside the window are **unique**\n\nWe expand the window using `right`  \nWe shrink the window using `left` when a duplicate appears\n\n---\n\n## Pointer Roles\n\n### Left Pointer (`l`)\n- Marks the **start of the current window**\n- Moves forward to remove duplicates\n\n### Right Pointer (`r`)\n- Expands the window by adding new characters\n\n---\n\n## Supporting Data Structure\n\nWe need to **track characters inside the window**.\n\nTypical choices:\n- `set<char>`\n- `unordered_set<char>`\n- Frequency array (for ASCII)\n\nThis does **NOT** violate space constraints.\n\n---\n\n## Window Rules (CRITICAL)\n\nAt any point:\\\nWindow s[l..r] contains NO duplicate characters\n\n---\n\n## Pointer Movement Rules\n\n### Case 1: `s[r]` is NOT in the window\n- Add `s[r]` to the set\n- Update maximum length\n- Move `r++`\n\n### Case 2: `s[r]` IS already in the window\n- Remove `s[l]` from the set\n- Move `l++`\n- Do NOT move `r` yet\n\nWhy?\n- We must shrink until duplicate is removed\n\n---\n\n## Loop Condition\n\nwhile (r < n)\n\n---\n\n## Dry Run Example (Key One)\n\nInput:\\\ns = \"pwwkew\"\n\nSteps:\\\nl=0, r=0 → 'p' → window={p} → max=1\\\nl=0, r=1 → 'w' → window={p,w} → max=2\\\nl=0, r=2 → 'w' → duplicate\\\nremove 'p' → l=1\\\nremove 'w' → l=2\\\nl=2, r=2 → add 'w' → window={w}\\\nl=2, r=3 → 'k' → window={w,k} → max=2\\\nl=2, r=4 → 'e' → window={w,k,e} → max=3\\\nl=2, r=5 → 'w' → duplicate\\\nremove 'w' → l=3\n\n\nResult: 3\n\n---\n\n## Time and Space Complexity\n\n- Time Complexity: `O(n)`\n- Space Complexity: `O(min(n, charset))`\n\n---\n\n## Common Mistakes to Avoid\n\n- Moving both pointers at once\n- Clearing the entire window on duplicate\n- Using nested loops\n- Forgetting substring must be contiguous\n\n---\n\n## Interview One-Line Explanation\n\n> I use a sliding window with two pointers to maintain a substring with unique characters.\n> When a duplicate appears, I shrink the window from the left until the duplicate is removed.\n\n---\n\n## Pattern Recognition Trigger\n\nIf a problem mentions:\n- Longest / smallest substring\n- Contiguous window\n- Condition-based expansion & shrinking\n\nThink immediately:\n**Sliding Window (Two Pointers)**\n\n\n\n\n\n\n\n",
      "code": "/*\nGiven a string s, find the length of the longest substring without repeating characters.\nA substring is a contiguous sequence of characters.\n */\n\n#include <iostream>\n#include <vector>\n#include <unordered_set>\n\nusing namespace std;\n\nint longestSubString(vector<char>& v) {\n    int l = 0, r = 0;\n    int max_substring = 0;\n    unordered_set<char> mySet = {};\n    for (r = 0; r < v.size(); r++) {\n        // Check for violation, means v[r] present in set\n        while (mySet.count(v[r])) {\n            mySet.erase(v[l]);\n            l++;\n        }\n\n        mySet.insert(v[r]);\n        max_substring = max(max_substring, r - l + 1);\n    }\n    return max_substring;\n}\n\nint main() {\n    vector<char> v = {'p', 'w', 'w', 'k', 'e', 'w'};\n    int ans = longestSubString(v);\n\n    cout << \"Longest substring is \" << longestSubString(v) << endl;\n\n    return 0;\n}\n",
      "difficulty": "Medium",
      "topic": "Array",
      "date": "Invalid Date",
      "id": 1769191988852,
      "type": "log",
      "subtopic": "Two Pointer + Sliding Window"
    },
    {
      "title": "You are given a sorted array of integers nums.  Remove the duplicates in-place such that each unique element appears only once.  The relative order of the elements must be kept the same.  Return the number of unique elements.  You must do this using O(1) extra space.",
      "logic": "# Two Pointers – Problem 4 (Remove Duplicates from Sorted Array)\n\n## Problem Statement\n\nYou are given a **sorted array of integers** `nums`.\n\nRemove the duplicates **in-place** such that each unique element appears **only once**.\n\nThe relative order of the elements must be kept the same.\n\nReturn the number of **unique elements**.\n\nYou must do this using **O(1) extra space**.\n\n---\n\n## Example\n\nInput:\\\nnums = [1,1,2,2,3,3,3,4]\n\nAfter modification:\\\nnums = [1,2,3,4,,,,]\n\nReturn: 4\n\n(The values beyond index 3 do not matter)\n\n---\n\n## Pattern Recognition\n\nClues in the problem:\n- Sorted array\n- In-place modification\n- Remove duplicates\n- Order must be preserved\n\n➡️ **Two Pointers**\n\n---\n\n## Core Idea\n\nBecause the array is sorted:\n- All duplicates are **adjacent**\n- We can overwrite duplicates instead of deleting elements\n\nOne pointer tracks the **last unique position**  \nAnother pointer scans the array\n\n---\n\n## Pointer Roles (VERY IMPORTANT)\n\n### Slow Pointer (`i`)\n- Marks the position of the **last unique element**\n- Controls where the next unique value should be placed\n\n### Fast Pointer (`j`)\n- Scans the array to find the next **new (different)** value\n\n---\n\n## Pointer Initialization\n\ni = 0 // first element is always unique\\\nj = 1 // start scanning from second element\n\n\n---\n\n## Pointer Movement Rules\n\nFor each `j` from `1` to `n-1`:\n\n### Case 1: `nums[j] == nums[i]`\n- Duplicate found\n- Ignore it\n- Move `j++`\n\n### Case 2: `nums[j] != nums[i]`\n- New unique element found\n- Increment `i`\n- Copy: nums[i] = nums[j]\n- Move `j++`\n\n---\n\n## Loop Condition\n\nwhile (j < n)\n\n---\n\n## Return Value\n\nNumber of unique elements = i + 1\n\nWhy?\n- `i` is index-based\n- Count = index + 1\n\n---\n\n## Dry Run Example\n\nInput:\\\n[1,1,2,2,3,3,3,4]\n\nSteps:\\\ni=0 (1), j=1 (1) → duplicate → j++\\\ni=0 (1), j=2 (2) → new → i=1, nums[1]=2\\\ni=1 (2), j=3 (2) → duplicate → j++\\\ni=1 (2), j=4 (3) → new → i=2, nums[2]=3\\\ni=2 (3), j=5 (3) → duplicate → j++\\\ni=2 (3), j=6 (3) → duplicate → j++\\\ni=2 (3), j=7 (4) → new → i=3, nums[3]=4\n\nResult:\\\nUnique count = 4\nArray prefix = [1,2,3,4]\n\n---\n\n## Time and Space Complexity\n\n- Time Complexity: `O(n)`\n- Space Complexity: `O(1)`\n\n---\n\n## Common Mistakes to Avoid\n\n- Using extra arrays\n- Shifting elements repeatedly\n- Forgetting to return `i + 1`\n- Comparing wrong indices\n\n---\n\n## Interview One-Line Explanation\n\n> Since the array is sorted, duplicates are adjacent.  \n> I use two pointers: one to track the last unique element and one to scan the array, overwriting duplicates in-place.\n\n---\n\n## Pattern Recognition Trigger\n\nIf a problem mentions:\n- Sorted array\n- In-place removal\n- Duplicates\n\nThink immediately:\n**Two Pointers (slow–fast)**\n",
      "code": "/*\nYou are given a sorted array of integers nums.\nRemove the duplicates in-place such that each unique element appears only once.\nThe relative order of the elements must be kept the same.\nReturn the number of unique elements.\nYou must do this using O(1) extra space.\n*/\n\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint findUnique(vector<int> &v) {\n    int i = 0, j = 1;\n    while (j < v.size()) {\n        if (v[i] == v[j]) {\n            j++;\n        } else{\n            i++;\n            v[i] = v[j];\n            j++;\n        }\n        \n    }\n    return i+1;\n}\n\nint main() {\n    vector<int> v = {1, 1, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5};\n    int num_of_element = findUnique(v);\n    cout << \"No of unique elements: \" << num_of_element << endl;\n    return 0;\n}",
      "difficulty": "Easy",
      "topic": "Array",
      "date": "Invalid Date",
      "id": 1768999249800,
      "type": "log",
      "subtopic": "Two Pointer"
    },
    {
      "title": "You are given an array height of non-negative integers. Each element represents the height of a vertical line drawn at that index. Choose two different lines such that together with the x-axis, they form a container that holds the maximum amount of water.",
      "logic": "# Two Pointers – Problem 3 (Container With Most Water)\n\n## Problem Statement\n\nYou are given an array `height` of non-negative integers.\n\nEach element represents the height of a vertical line drawn at that index.\n\nChoose **two different lines** such that together with the x-axis, they form a container that holds the **maximum amount of water**.\n\nReturn the **maximum water** the container can store.\n\n---\n\n## Example\n\nInput:\\\nheight = [1,8,6,2,5,4,8,3,7]\n\nOutput: 49\n\nExplanation:\n- Choose lines at index 2 (height 8) and index 9 (height 7)\n- Width = 8 - 1 = 7\n- Height = min(8, 7) = 7\n- Area = 7 × 7 = 49\n\n---\n\n## Pattern Recognition\n\nClues in the problem:\n- Two elements chosen\n- Array indices matter\n- Need maximum value\n- Brute force would be O(n²)\n\n**Two Pointers**\n\n---\n\n## Core Insight (THIS IS THE KEY)\n\nArea is determined by:\\\narea = width × min(height[left], height[right])\n\n- Width decreases as pointers move inward\n- Height is limited by the **shorter line**\n\n**The shorter line is the bottleneck**\n\n---\n\n## Pointer Initialization\n\n- `left = 0`\n- `right = n - 1`\n- `maxArea = 0`\n\n---\n\n## Pointer Movement Rule (CRITICAL)\n\n### Always move the pointer pointing to the **shorter height**\n\nWhy?\n- Moving the taller one cannot increase height\n- Only moving the shorter line gives a chance to increase `min(height)`\n\n---\n\n## Pointer Logic\n\nLet:\\\ncurrentHeight = min(height[left], height[right])\\\nwidth = right - left\\\narea = currentHeight × width\\\n\n\nSteps:\n1. Update `maxArea`\n2. If `height[left] < height[right]` → move `left++`\n3. Else → move `right--`\n\n---\n\n## Dry Run Example (Partial)\n\nInput:\\\n[1,8,6,2,5,4,8,3,7]\n\nSteps:\\\nL=1, R=7 → area=8\nMove L (shorter)\n\nL=8, R=7 → area=49 (max)\nMove R (shorter)\n\nContinue until L >= R\n\n---\n\n## Loop Condition\n\nwhile (left < right)\n\nWhy:\n- Need two distinct lines\n- All valid pairs covered before pointers cross\n\n---\n\n## Time and Space Complexity\n\n- Time Complexity: `O(n)`\n- Space Complexity: `O(1)`\n\n---\n\n## Common Mistakes to Avoid\n\n- Moving both pointers\n- Moving the taller pointer\n- Trying all pairs (O(n²))\n- Forgetting width calculation\n\n---\n\n## Interview One-Line Explanation\n\n> I use two pointers from both ends.  \n> The area depends on the shorter line, so I always move the pointer with the smaller height to potentially increase the area.\n\n---\n\n## Pattern Recognition Trigger\n\nIf a problem:\n- Chooses two indices\n- Mentions maximum area / volume\n- Depends on distance between indices\n\nThink immediately:\n**Two Pointers (Shrink from ends)**\n\n",
      "code": "/*\nYou are given an array height of non-negative integers.\nEach element represents the height of a vertical line drawn at that index.\nChoose two different lines such that together with the x-axis, they form\na container that holds the maximum amount of water.\nReturn the maximum water the container can store.\n*/\n\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint maxWaterTrapped(vector<int> &v) {\n    int i = 0, j = v.size()-1;\n    int max_water = 0;\n    while (i < j) {\n        int width = j-i;\n        max_water = max(max_water, width * min(v[i], v[j]));\n        if (v[i] <= v[j]) {\n            i++;\n        } else {\n            j--;\n        }\n    }\n    return max_water;\n    \n}\n\nint main() {\n    // vector<int> v = {1, 5, 6, 2, 5, 4, 8, 3, 7};\n    vector<int> v = {4, 3, 2, 1, 4};\n    int max_water = maxWaterTrapped(v);\n\n    cout << \"Maximum water trapped is \" << max_water << endl;\n\n    return 0;\n}",
      "difficulty": "Easy",
      "topic": "Array",
      "date": "Invalid Date",
      "id": 1768914124942,
      "type": "log",
      "subtopic": "Two Pointer"
    },
    {
      "title": "You are given a sorted array of integers numbers and an integer target.  Find two distinct elements in the array such that their sum equals target.  Return the indices (1-based) of these two elements.",
      "logic": "# Two Pointers – Problem 2 (Pair Sum with Indices)\n\n## Problem Statement\n\nYou are given a **sorted array of integers** `numbers` and an integer `target`.\n\nFind **two distinct elements** in the array such that their sum equals `target`.\n\nReturn the **indices (1-based)** of these two elements.\n\n### Constraints\n- The array is sorted in **non-decreasing order**\n- Exactly **one valid solution exists**\n- You may not use the same element twice\n- You must use **constant extra space**\n\n---\n\n## Example\n\nInput:\n \nnumbers = [2, 3, 3, 4, 6]\ntarget = 6\n\nOutput:\n[2, 3]\n\nExplanation:\\\nnumbers[2] + numbers[3] = 3 + 3 = 6\n\n\n---\n\n## Pattern Recognition\n\nClues in the problem:\n- Sorted array\n- Pair sum\n- Exactly one solution\n\n➡️ **Two Pointers**\n\nDuplicates do **not** change the algorithm.\n\n---\n\n## Core Idea\n\nBecause the array is sorted:\n- The left pointer starts from the smallest element\n- The right pointer starts from the largest element\n\nBy adjusting the pointers intelligently, we can find the pair in **O(n)** time.\n\n---\n\n## Pointer Initialization\n\n- `left = 0`\n- `right = n - 1`\n\n---\n\n## Pointer Movement Rules\n\nLet:\\\nsum = numbers[left] + numbers[right]\n\n\n### Case 1: `sum == target`\n- Pair found\n- Return indices: `[left + 1, right + 1]`\n\n### Case 2: ```sum < target```\n- Sum is too small\n- Move `left` pointer to the right (`left++`)\n\n### Case 3: `sum > target`\n- Sum is too large\n- Move `right` pointer to the left (`right--`)\n\n---\n\n## Loop Condition\n\nwhile (left < right)\n\nWhy:\n- Prevents using the same element twice\n- Ensures valid pair selection\n\n---\n\n## Dry Run Example\n\nInput:\\\nnumbers = [1, 1, 2, 3, 4, 4, 9]\ntarget = 8\n\nSteps:\\\nL=1, R=9 → sum=10 → move R\\\nL=1, R=4 → sum=5 → move L\\\nL=1, R=4 → sum=5 → move L\\\nL=2, R=4 → sum=6 → move L\\\nL=3, R=4 → sum=7 → move L\\\nL=4, R=4 → sum=8 → FOUND\n\nFinal Indices (1-based):\n[5, 6]\n\n\n---\n\n## Time and Space Complexity\n\n- Time Complexity: `O(n)`\n- Space Complexity: `O(1)`\n\n---\n\n## Common Mistakes to Avoid\n\n- Allowing `left == right`\n- Returning values instead of indices\n- Using hash maps unnecessarily\n- Forgetting 1-based indexing\n\n---\n\n## Interview One-Line Explanation\n\n> Since the array is sorted, I use two pointers from both ends.\n> I move the left pointer if the sum is too small and the right pointer if the sum is too large.\n> When the sum equals the target, I return the 1-based indices.\n\n---\n\n## Pattern Recognition Trigger\n\nIf a problem mentions:\n- Sorted array\n- Two numbers\n- Target sum\n\nThink immediately:\n**Two Pointers**\n",
      "code": "/*\nYou are given a sorted array of integers numbers and an integer target.\n\nFind two distinct elements in the array such that their sum equals target.\n\nReturn the indices (1-based) of these two elements.\n\nConstraints\nThe array is sorted in non-decreasing order\nExactly one valid solution exists\nYou may not use the same element twice\nYou must use constant extra space\n*/\n\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> twoSum(vector<int>& numbers, int target) {\n    int l = 0, r = numbers.size() - 1;\n\n    while (l < r) {\n        int sum = numbers[l] + numbers[r];\n\n        if (sum > target) {\n            r--;\n        } else if (sum < target) {\n            l++;\n        } else {\n            // return 1-based indices\n            return {l + 1, r + 1};\n        }\n    }\n\n    return {};\n}\n\n\nint main() {\n    vector<int> v = {1, 1, 2, 3, 4, 4, 9};\n    int target = 15;\n    vector<int> res = twoSum(v, target);\n    \n    if (res.size() == 0) {\n        cout << \"not found\" << endl;\n    } else {\n        cout << \"Two Sum: \" << res[0] << \", \" << res[1] << endl;\n    }\n\n    return 0;\n}\n",
      "difficulty": "Easy",
      "topic": "Array",
      "date": "Invalid Date",
      "id": 1768876505216,
      "type": "log",
      "subtopic": "Two Pointer"
    },
    {
      "title": "Given a sorted array of integers and a target value, determine if there exist two numbers whose sum equals the target",
      "logic": "# Two Pointers Technique (Pattern Notes)\n\n## When to Use Two Pointers\n\nUse **Two Pointers** when you see:\n- Sorted array or sorted string\n- Problems asking for a pair / triplet\n- Conditions like sum, difference, comparison\n- Need to optimize from O(n²) to O(n)\n\n---\n\n## Canonical Problem Type\n\n> Given a sorted array, determine if there exist two elements whose sum equals a target.\n\n---\n\n## Core Idea\n\nBecause the array is **sorted**:\n- Left side has the smallest values\n- Right side has the largest values\n\nUsing two pointers allows us to adjust the sum intelligently instead of checking all pairs.\n\n---\n\n## Pointer Initialization\n\n- `left` starts at index `0`\n- `right` starts at index `n - 1`\n\n---\n\n## Pointer Movement Rules (Key Logic)\n\nLet: current_sum = nums[left] + nums[right]\n\n\n### If `current_sum == target`\n- Pair found\n- Return `true`\n\n### If `current_sum < target`\n- Sum is too small\n- Move `left` pointer to the right (`left++`)\n- Reason: increase the sum\n\n### If `current_sum > target`\n- Sum is too large\n- Move `right` pointer to the left (`right--`)\n- Reason: decrease the sum\n\n---\n\n## Loop Condition\n\nwhile (left < right)\n\n\nReason:\n- A number cannot pair with itself\n- All valid pairs are checked before pointers cross\n\n---\n\n## Dry Run Example\n\nArray: `[1, 2, 4, 6, 9]`\n\nTarget: 8\n\nSteps: \\\nL=1, R=9 → sum=10 → move R \\\nL=1, R=6 → sum=7 → move L \\\nL=2, R=6 → sum=8 → found \n\n\n---\n\n## Time & Space Complexity\n\n- Time Complexity: `O(n)`\n- Space Complexity: `O(1)`\n\n---\n\n## Common Mistakes to Avoid\n\n- Using nested loops\n- Ignoring the sorted property\n- Moving both pointers at the same time\n- Using extra data structures unnecessarily\n\n---\n\n## Interview One-Line Explanation\n\n> Since the array is sorted, I use two pointers from both ends.\n> If the sum is smaller than the target, I move the left pointer.\n> If it is larger, I move the right pointer.\n\n---\n\n## Pattern Recognition Trigger\n\nIf a problem mentions:\n- Sorted array\n- Pair of elements\n- Sum or comparison\n\nThink immediately:\n**Two Pointers**\n",
      "code": "/*\nGiven a sorted array of integers and a target value, determine if there exist two numbers\nwhose sum equals the target\n*/\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool hasPairWithSum(vector<int>& nums, int target) {\n    int l = 0, r = nums.size() - 1;\n\n    while (l < r) {\n        int sum = nums[l] + nums[r];\n\n        if (sum < target) {\n            l++;\n        } else if (sum > target) {\n            r--;\n        } else {\n            return true;\n        }\n    }\n    return false;\n}\n\n\nint main() {\n    vector<int> v = {2, 3, 5, 8, 11};\n    int target = 16;\n\n    bool present = hasPairWithSum(v, target);\n\n    cout << \"The target is \" << present << endl;\n\n    return 0;\n}\n",
      "difficulty": "Easy",
      "topic": "Array",
      "date": "Invalid Date",
      "id": 1768830769172,
      "type": "log",
      "subtopic": "Two Pointer"
    }
  ],
  "history": [
    "19/01/2026",
    "20/01/2026",
    "21/01/2026",
    "23/01/2026",
    "Invalid Date"
  ],
  "practice": [],
  "theory": [
    {
      "id": 1769143787001,
      "title": "OSI-TCP/IP",
      "topic": "OSI-TCP/IP",
      "date": "2026-01-23",
      "content": "# Networking Fundamentals – OSI, TCP/IP\n\n---\n\n## 1. Why Do We Need Layers?\n\nNetworking is complex. Layers exist to:\n- Break the problem into manageable parts\n- Assign clear responsibilities\n- Make debugging easier\n- Allow independent evolution of protocols\n\n**Key idea:**  \nLayers define *who is responsible for what*.\n\n---\n\n## 2. OSI vs TCP/IP – Purpose, Not Theory\n\n### OSI Model\n- 7-layer **conceptual model**\n- Used for:\n  - Learning\n  - Design thinking\n  - Debugging\n- Not implemented strictly in real systems\n\n### TCP/IP Model\n- Practical model\n- What actually runs the Internet\n- Fewer layers, based on real-world needs\n\n---\n\n## 3. OSI Layers\n- Application\n- Presentation\n- Session\n- Transport\n- Network\n- Data Link\n- Physical\n\n---\n\n## 4. TCP/IP Layers\n- Application\n- Transport\n- Internet\n- Network Access\n\n\n---\n\n## 5. OSI ↔ TCP/IP Mapping\n\n| OSI Layer        | Responsibility                     | TCP/IP Layer      |\n|------------------|------------------------------------|-------------------|\n| Application (7)  | HTTP, FTP, DNS                     | Application       |\n| Presentation (6) | Encryption, encoding, compression  | Application       |\n| Session (5)      | Session management                 | Application       |\n| Transport (4)    | TCP, UDP, ports                    | Transport         |\n| Network (3)      | IP, routing                        | Internet          |\n| Data Link (2)    | Ethernet, MAC, ARP                 | Network Access    |\n| Physical (1)     | Bits, signals, wire                | Network Access    |\n\n### Why layers are merged in TCP/IP\n- Presentation & Session logic handled by applications/libraries\n- Physical & Data Link tightly coupled in hardware\n- TCP/IP favors practicality over strict separation\n\n---\n\n## 6. Key Interview Insight\n\n- **OSI** → thinking, debugging, explanation\n- **TCP/IP** → implementation, real traffic\n\n> OSI is the map, TCP/IP is the territory.\n\n---"
    }
  ]
}